







// [Folder] controllers








// C:\Users\kebic\OneDrive\Desktop\car_rent\car_rent_backend\src\controllers\authController.ts
import { Request, Response } from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import User, { IUser } from '../models/User';
import { validationResult } from 'express-validator';

export const register = async (req: Request, res: Response) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { name, email, password, phone, role } = req.body;

  try {
    // Check if user exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'Email already in use' });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Set status to 'pending' for owners
    const status = role === 'owner' ? 'pending' : 'active';

    // Create user
    const user = new User({
      name,
      email,
      password: hashedPassword,
      phone,
      role,
      status,
      joinDate: new Date()
    });

    await user.save();

    // Generate JWT
    const token = jwt.sign(
      { userId: user._id, role: user.role },
      process.env.JWT_SECRET as string,
      { expiresIn: '1d' }
    );

    res.status(201).json({ token, user: { id: user._id, name, email, role, status } });
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
};

export const login = async (req: Request, res: Response) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { email, password } = req.body;

  try {
    // Find user
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    // Check password
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    // Check if owner is approved
    if (user.role === 'owner' && user.status === 'pending') {
      return res.status(403).json({ message: 'Account awaiting admin approval' });
    }

    // Generate JWT
    const token = jwt.sign(
      { userId: user._id, role: user.role },
      process.env.JWT_SECRET as string,
      { expiresIn: '1d' }
    );

    res.json({ token, user: { id: user._id, name: user.name, email, role: user.role, status: user.status } });
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
};









// [Folder] middleware








// C:\Users\kebic\OneDrive\Desktop\car_rent\car_rent_backend\src\middleware\authMiddleware.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

interface AuthRequest extends Request {
  user?: { userId: string; role: string };
}

export const authMiddleware = (req: AuthRequest, res: Response, next: NextFunction) => {
  const token = req.header('Authorization')?.replace('Bearer ', '');

  if (!token) {
    return res.status(401).json({ message: 'No token provided' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET as string) as { userId: string; role: string };
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ message: 'Invalid token' });
  }
};

export const roleMiddleware = (roles: string[]) => {
  return (req: AuthRequest, res: Response, next: NextFunction) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ message: 'Access denied' });
    }
    next();
  };
};









// [Folder] models








// C:\Users\kebic\OneDrive\Desktop\car_rent\car_rent_backend\src\models\Booking.ts
import mongoose, { Schema, Document } from 'mongoose';

export interface IBooking extends Document {
  userId: mongoose.Types.ObjectId;
  carId: mongoose.Types.ObjectId;
  startDate: Date;
  endDate: Date;
  totalAmount: number;
  status: 'pending' | 'confirmed' | 'completed' | 'cancelled';
  pickupLocation: string;
  dropoffLocation: string;
  additionalServices: string[];
  paymentMethod: 'credit-card' | 'paypal';
  createdAt: Date;
  updatedAt: Date;
}

const BookingSchema: Schema = new Schema({
  userId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  carId: { type: Schema.Types.ObjectId, ref: 'Car', required: true },
  startDate: { type: Date, required: true },
  endDate: { type: Date, required: true },
  totalAmount: { type: Number, required: true },
  status: { type: String, enum: ['pending', 'confirmed', 'completed', 'cancelled'], default: 'pending' },
  pickupLocation: { type: String, required: true },
  dropoffLocation: { type: String, required: true },
  additionalServices: [{ type: String }],
  paymentMethod: { type: String, enum: ['credit-card', 'paypal'], required: true },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

export default mongoose.model<IBooking>('Booking', BookingSchema);







// C:\Users\kebic\OneDrive\Desktop\car_rent\car_rent_backend\src\models\Car.ts
import { Schema, Document, Types, model } from 'mongoose';

// Define the ICar interface
export interface ICar extends Document {
  brand: string;
  carModel: string; 
  year: number;
  price: number;
  image: string;
  category: 'Economy' | 'Compact' | 'SUV' | 'Luxury' | 'Sports';
  transmission: 'Manual' | 'Automatic';
  fuel: 'Petrol' | 'Diesel' | 'Electric' | 'Hybrid';
  seats: number;
  available: boolean;
  features: string[];
  location: string;
  rating: number;
  ownerId: Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const CarSchema: Schema<ICar> = new Schema({
  brand: { type: String, required: true },
  carModel: { type: String, required: true }, // Renamed field
  year: { type: Number, required: true },
  price: { type: Number, required: true },
  image: { type: String, required: true },
  category: { type: String, enum: ['Economy', 'Compact', 'SUV', 'Luxury', 'Sports'], required: true },
  transmission: { type: String, enum: ['Manual', 'Automatic'], required: true },
  fuel: { type: String, enum: ['Petrol', 'Diesel', 'Electric', 'Hybrid'], required: true },
  seats: { type: Number, required: true },
  available: { type: Boolean, default: true },
  features: [{ type: String }],
  location: { type: String, required: true },
  rating: { type: Number, default: 0 },
  ownerId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

export default model<ICar>('Car', CarSchema);







// C:\Users\kebic\OneDrive\Desktop\car_rent\car_rent_backend\src\models\Testimonial.ts
import mongoose, { Schema, Document } from 'mongoose';

export interface ITestimonial extends Document {
  name: string;
  location: string;
  rating: number;
  comment: string;
  avatar: string;
  userId: mongoose.Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const TestimonialSchema: Schema = new Schema({
  name: { type: String, required: true },
  location: { type: String, required: true },
  rating: { type: Number, required: true, min: 1, max: 5 },
  comment: { type: String, required: true },
  avatar: { type: String, required: true },
  userId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

export default mongoose.model<ITestimonial>('Testimonial', TestimonialSchema);







// C:\Users\kebic\OneDrive\Desktop\car_rent\car_rent_backend\src\models\User.ts
import mongoose, { Schema, Document } from 'mongoose';

export interface IUser extends Document {
  name: string;
  email: string;
  password: string;
  phone: string;
  role: 'customer' | 'admin' | 'owner';
  joinDate: Date;
  status: 'active' | 'inactive' | 'pending';
  createdAt: Date;
  updatedAt: Date;
}

const UserSchema: Schema = new Schema({
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  phone: { type: String, required: true },
  role: { type: String, enum: ['customer', 'admin', 'owner'], required: true },
  joinDate: { type: Date, default: Date.now },
  status: { type: String, enum: ['active', 'inactive', 'pending'], default: 'active' },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

export default mongoose.model<IUser>('User', UserSchema);









// [Folder] routes








// C:\Users\kebic\OneDrive\Desktop\car_rent\car_rent_backend\src\routes\authRoutes.ts
import { Router } from 'express';
import { register, login } from '../controllers/authController';
import { check } from 'express-validator';

const router = Router();

router.post(
  '/register',
  [
    check('name', 'Name is required').not().isEmpty(),
    check('email', 'Please include a valid email').isEmail(),
    check('password', 'Password must be at least 6 characters').isLength({ min: 6 }),
    check('phone', 'Phone number is required').not().isEmpty(),
    check('role', 'Invalid role').isIn(['customer', 'owner'])
  ],
  register
);

router.post(
  '/login',
  [
    check('email', 'Please include a valid email').isEmail(),
    check('password', 'Password is required').exists()
  ],
  login
);

export default router;









// [Folder] scripts








// C:\Users\kebic\OneDrive\Desktop\car_rent\car_rent_backend\src\scripts\extract_code.js
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

// Get __dirname equivalent in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Go up one level to the main module directory
const sourceFolder = path.resolve(__dirname, '..');
const outputFile = path.join(__dirname, 'car_code_output.txt');
const extensions = ['.py', '.xml', '.csv', '.js', '.css', '.tsx', '.ts', 'jsx']; // Added .tsx for About.tsx

function concatenateFiles(folderPath, depth = 0) {
  const files = fs.readdirSync(folderPath);
  let fileContent = '';
  let folderContent = '';

  files.forEach(file => {
    const filePath = path.join(folderPath, file);
    const stats = fs.statSync(filePath);

    if (stats.isDirectory()) {
      const subContent = concatenateFiles(filePath, depth + 1);
      if (subContent && subContent.trim()) {
        folderContent += `\n\n\n\n\n\n\n\n// ${'  '.repeat(depth)}[Folder] ${file}\n${subContent}\n\n`;
      }
    } else {
      for (const ext of extensions) {
        if (file.endsWith(ext)) {
          const fileData = fs.readFileSync(filePath, 'utf-8');
          fileContent += `\n\n\n\n\n\n\n\n// ${filePath}\n${fileData}`;
          break;
        }
      }
    }
  });

  return folderContent + fileContent;
}

// Start with a clean output file
fs.writeFileSync(outputFile, '', 'utf-8');
const allContent = concatenateFiles(sourceFolder);
fs.appendFileSync(outputFile, allContent, 'utf-8');

console.log(`✅ Code extracted to: ${outputFile}`);










// C:\Users\kebic\OneDrive\Desktop\car_rent\car_rent_backend\src\app.ts
import express, { Application } from 'express';
import mongoose from 'mongoose';
import dotenv from 'dotenv';
import authRoutes from './routes/authRoutes';

dotenv.config();

const app: Application = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(express.json());

// Routes
app.use('/api/auth', authRoutes);

// MongoDB Connection
mongoose.connect(process.env.MONGODB_URI as string)
  .then(() => console.log('Connected to MongoDB'))
  .catch((err) => console.error('MongoDB connection error:', err));

// Start Server
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});







// C:\Users\kebic\OneDrive\Desktop\car_rent\car_rent_backend\src\seed.ts
import mongoose from 'mongoose';
import bcrypt from 'bcrypt';
import dotenv from 'dotenv';
import User from './models/User';
import Car from './models/Car';
import Booking from './models/Booking';
import Testimonial from './models/Testimonial';

dotenv.config();

async function seedDatabase() {
  try {
    await mongoose.connect(process.env.MONGODB_URI as string);
    console.log('Connected to MongoDB');

    // Clear existing data (optional, comment out to keep existing data)
    await User.deleteMany({});
    await Car.deleteMany({});
    await Booking.deleteMany({});
    await Testimonial.deleteMany({});
    console.log('Cleared existing data');

    // Insert users
    const hashedPassword = await bcrypt.hash('password123', 10);
    const users = await User.insertMany([
      {
        name: 'John Doe',
        email: 'john@example.com',
        password: hashedPassword,
        phone: '+1234567890',
        role: 'customer',
        status: 'active'
      },
      {
        name: 'Jane Owner',
        email: 'jane@example.com',
        password: hashedPassword,
        phone: '+1234567891',
        role: 'owner',
        status: 'active' // Active for testing
      },
      {
        name: 'Admin User',
        email: 'admin@example.com',
        password: hashedPassword,
        phone: '+1234567899',
        role: 'admin',
        status: 'active'
      }
    ]);
    console.log('Inserted users');

    // Find owner
    const owner = users.find((u: any) => u.role === 'owner');
    if (!owner) {
      throw new Error('No owner user found');
    }
    const ownerId = owner._id;

    // Insert cars
    const cars = await Car.insertMany([
      {
        brand: 'Toyota',
        carModel: 'Camry', // Updated to carModel
        year: 2023,
        price: 45,
        image: 'https://images.pexels.com/photos/116675/pexels-photo-116675.jpeg?auto=compress&cs=tinysrgb&w=500',
        category: 'Compact',
        transmission: 'Automatic',
        fuel: 'Petrol',
        seats: 5,
        available: true,
        features: ['GPS', 'AC', 'Bluetooth'],
        location: 'Downtown',
        rating: 4.5,
        ownerId: ownerId
      },
      {
        brand: 'BMW',
        carModel: 'X5', // Updated to carModel
        year: 2023,
        price: 95,
        image: 'https://images.pexels.com/photos/244206/pexels-photo-244206.jpeg?auto=compress&cs=tinysrgb&w=500',
        category: 'SUV',
        transmission: 'Automatic',
        fuel: 'Petrol',
        seats: 7,
        available: true,
        features: ['GPS', 'Leather Seats', 'Sunroof'],
        location: 'Airport',
        rating: 4.8,
        ownerId: ownerId
      }
    ]);
    console.log('Inserted cars');

    // Find customer
    const customer = users.find((u: any) => u.role === 'customer');
    if (!customer) {
      throw new Error('No customer user found');
    }
    const customerId = customer._id;

    // Insert bookings
    await Booking.insertMany([
      {
        userId: customerId,
        carId: cars[0]._id,
        startDate: new Date('2025-08-15'),
        endDate: new Date('2025-08-18'),
        totalAmount: 135,
        status: 'confirmed',
        pickupLocation: 'Downtown Office',
        dropoffLocation: 'Airport',
        additionalServices: ['gps', 'insurance'],
        paymentMethod: 'credit-card'
      }
    ]);
    console.log('Inserted bookings');

    // Insert testimonials
    await Testimonial.insertMany([
      {
        name: 'Emily Davis',
        location: 'New York, NY',
        rating: 5,
        comment: 'Excellent service!',
        avatar: 'https://images.pexels.com/photos/774909/pexels-photo-774909.jpeg?auto=compress&cs=tinysrgb&w=150',
        userId: customerId
      }
    ]);
    console.log('Inserted testimonials');

    console.log('Database seeded successfully!');
  } catch (error) {
    console.error('Error seeding database:', error);
  } finally {
    await mongoose.disconnect();
    console.log('Disconnected from MongoDB');
  }
}

seedDatabase();